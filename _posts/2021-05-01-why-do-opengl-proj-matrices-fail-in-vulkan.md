---
title: "Why projection matrices typically used with OpenGL fail with Vulkan"
# last_modified_at: 2021-05-01T18:00:00+02:00
categories:
  - GPU-Programming
tags:
  - Vulkan
# header:
#   image: /assets/images/1500x500.jpg
---

When programmers with an OpenGL background learn Vulkan, they often expect--or hope--that the projection matrices they have used with OpenGL continue to work with Vulkan. Everyone with such expectations is in for a bad surprise. While many sources on the internet offer quick fixes such as

- Inverting the projection matrix' y-axis: `projMat[1][1] *= -1`
- Inverting the y coordinates in the vertex shader: `gl_Position.y = -gl_Position.y;`
- Inverting the projection matrix' z-axis: `projMat[2][3] *= -1` (TODO: check!)
- Changing the front faces from [`VK_FRONT_FACE_COUNTER_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html) to [`VK_FRONT_FACE_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html)

Applying such fixes without really knowing what's going on under the hood can leave a bad feeling in the mind of a thoughtful programmer. This blog post tries to explain why OpenGL's projection matrices do not work in a Vulkan application without modification and what the fundamental differences between the two APIs are in this specific case.

I'll try to make the points I'm going to make visually with images and animations, and minimize the mathematical parts to what is absolutely necessary. 

## The OpenGL Way

Before we can analyze the differences between Vulkan and OpenGL, we should try to understand what happens in OpenGL and why projection matrices of the following form are used:

$$ \begin{pmatrix}
\frac{2 n}{r - l} & 0 & \frac{r + l}{r - l} & 0 \\
0 & \frac{2 n}{t - b} & \frac{t + b}{t - b} & 0 \\
0 & 0 & -\frac{f + n}{f - n} & -1 \\
0 & 0 & \frac{2 f n}{f - n} & 0 
\end{pmatrix} $$      
_Equation 1:_ Typical OpenGL projection matrix as generated by good old [`glFrustum`](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml) (or with better formatting here: [Scratchpixel 2.0 - The Perspective and Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix). 

Now, this might look a bit complicated at first glance, but the fundamental ideas are not so involved once we simplify it a bit. The variables refer to: near plane distance $n$, far plane distance $f$, left and right frustum boundaries $l$ and $r$, top and bottom frustum boundaries $t$ and $b$. These parameters are for transforming a scene into a unit cube. Let us simplify computations by assuming that our entire scene is contained within ~unit cube bounds already, then the projection matrix looks a lot simpler turns from its form in _Equation 1_ into the form in _Equation 2_:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix} $$   
_Equation 2:_ Projection matrix with parameters $l = -1$, $r = 1$, $b = -1$, $t = 1$, $n = 1$, and $f = 2$.

What I would like to point out now is how this projection matrix transforms coordinates. We are about to whitness some---in my opinion---rather ugly conventions which have the potential to lead to a lot of confusion. 

_Speaking of confusion, a sidenote:_ Don't let yourself be confused by the positions of the $-1$ and $-4$ entries in _Equation 2_, since you'll find their positions swapped in many references. This comes from taking taking storage peculiarities into account---namely row-mayor vs. column-major. In this blog post, however, I just print a matrix in generic mathematical notation s.t. it matches the notation from e.g. [WolframAlpha](https://www.wolframalpha.com/input/?i=%7B%7B1%2C+0%2C+0%2C+0%7D%2C+%7B0%2C+1%2C+0%2C+0%7D%2C+%7B0%2C+0%2C+-3%2C+-1%7D%2C+%7B0%2C+0%2C+-4%2C+0%7D%7D+.+%7B%7B1%7D%2C+%7B1%7D%2C+%7B1%7D%2C+%7B1%7D%7D) and other mathematical sources.

Okay, back to the projection matrix. Let us investigate what it does to our coordinate values by transforming a homogeneous 3D vector with it:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix}            \cdot 
\begin{pmatrix}
x \\
y \\
z \\
1 \end{pmatrix}            = 
\begin{pmatrix}
x \\
y \\
-3z-1 \\
-4z  
\end{pmatrix} $$   

