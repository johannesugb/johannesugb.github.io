---
title: "Why projection matrices typically used with OpenGL fail with Vulkan"
# last_modified_at: 2021-05-01T18:00:00+02:00
categories:
  - GPU-Programming
tags:
  - Vulkan
# header:
#   image: /assets/images/1500x500.jpg
---

When programmers with an OpenGL background learn Vulkan, they often expect--or hope--that the projection matrices they have used with OpenGL continue to work with Vulkan. Everyone with such expectations is in for a bad surprise. While many sources on the internet offer quick fixes such as

- Inverting the projection matrix' y-axis: `projMat[1][1] *= -1`
- Inverting the y coordinates in the vertex shader: `gl_Position.y = -gl_Position.y;`
- Inverting the projection matrix' z-axis: `projMat[2][3] *= -1` (TODO: check!)
- Changing the front faces from [`VK_FRONT_FACE_COUNTER_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html) to [`VK_FRONT_FACE_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html)

Applying such fixes without really knowing what's going on under the hood can leave a bad feeling in the mind of a thoughtful programmer. This blog post tries to explain why OpenGL's projection matrices do not work in a Vulkan application without modification and what the fundamental differences between the two APIs are in this specific case.

## Projection Matrices in OpenGL

Before we can analyze the differences between Vulkan and OpenGL, we should try to understand what happens in OpenGL and why projection matrices of the following form are used:

$$ \begin{pmatrix}
\frac{2 n}{r - l} & 0 & \frac{r + l}{r - l} & 0 \\
0 & \frac{2 n}{t - b} & \frac{t + b}{t - b} & 0 \\
0 & 0 & -\frac{f + n}{f - n} & -1 \\
0 & 0 & \frac{2 f n}{f - n} & 0 
\end{pmatrix} $$      

_Equation 1:_ Typical OpenGL projection matrix as generated by good old [`glFrustum`](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml) (or with better formatting here: [Scratchpixel 2.0 - The Perspective and Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix). 

Now, this might look a bit complicated at first glance, but the fundamental ideas are not so involved once we simplify it a bit. The variables refer to: near plane distance $n$, far plane distance $f$, left and right frustum boundaries $l$ and $r$, top and bottom frustum boundaries $t$ and $b$. These parameters are for transforming a scene into a unit cube. Let us simplify computations by assuming that our entire scene is contained within ~unit cube bounds already, then the projection matrix looks a lot simpler turns from its form in _Equation 1_ into the form in _Equation 2_:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix} $$          

_Equation 2:_ Projection matrix with parameters $l = -1$, $r = 1$, $b = -1$, $t = 1$, $n = 1$, and $f = 2$.

What I would like to point out now is how this projection matrix transforms coordinates. We are about to whitness some---in my opinion---rather ugly conventions which have the potential to lead to a lot of confusion. 

_Speaking of confusion, a sidenote:_ Don't let yourself be confused by the positions of the $-1$ and $-4$ entries in _Equation 2_; you'll find their positions swapped in many references. This comes from taking taking storage peculiarities into account---namely row-mayor vs. column-major. In this blog post, however, I display matrices in generic mathematical notation s.t. it matches the notation from e.g. [WolframAlpha](https://www.wolframalpha.com/input/?i=%7B%7B1%2C+0%2C+0%2C+0%7D%2C+%7B0%2C+1%2C+0%2C+0%7D%2C+%7B0%2C+0%2C+-3%2C+-1%7D%2C+%7B0%2C+0%2C+-4%2C+0%7D%7D+.+%7B%7Bx%7D%2C+%7By%7D%2C+%7Bz%7D%2C+%7B1%7D%7D) and other mathematical sources.

Okay, back to the projection matrix. Let us investigate what it does to coordinate values by using it to transform a homogeneous 3D vector:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix}            \cdot 
\begin{pmatrix}
x \\
y \\
z \\
1 \end{pmatrix}            = 
\begin{pmatrix}
x \\
y \\
-3z-1 \\
-4z  
\end{pmatrix} $$         

_Equation 3:_ Transforming a homogeneous 3D vector with the projection matrix from _Equation 2_.

While it leaves $x$ and $y$ coordinates untouched, $z$ cooordinates get **flipped**. Furthermore, we get a **negative homogeneous coordinate**. 
Flipping of one coordinate axis _only_, while not flipping the other two axes, corresponds to **changing the handedness** of the coordinate system as illustrated in _Figure 1_.

{: text-align: center;}
[![Flipping the z-axis only](/assets/images/inv-z-fade.gif)](/assets/images/inv-z-fade.gif)

_Figure 1:_ Illustration of the transformation from _Equation 3_. Of course, matrix multiplication would not lead to an interpolation like shown in the animation; the animation shall just illustrate what happens: One coordinate axis is flipped while the others remain in place---turning the original right-handed coordinate system into a left-handed coordinate system.

The coordinate system that results from it is left-handed because OpenGL's convention of framebuffer coordinates are that in screen space, the x-axis is pointing to the right, y-axis is pointing up, and the z-axis, which represents depth values, points "into" the screen (i.e. _not_ out of it). A nice illustration of the different framebuffer coordinates spaces in screen space can be found under [Sascha Willems - Flipping the Vulkan viewport](https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/). 

And with this information, let us move on where it get
