---
title: "JavaScript Test"
# last_modified_at: 2021-03-02T19:00:00+01:00
categories:
#  - Vulkan
tags:
#  - Vulkan
#  - synchronization
# header:
#   image: /assets/images/1500x500.jpg
---

<h1>Floating Point Precision Calculator</h1>

<p> 
    <!-- Making a text input -->
	<table>
	<tr>
		<td><label for="fromVal">Calculate float precision between: </label></td>
		<td><input type="number" step="any" id="fromVal" placeholder="Float" style="width: 130px;"/> </td>
		<td><label for="toVal">and:</label></td>
		<td><input type="number" step="any" id="toVal" placeholder="Float"  style="width: 130px;"/> </td>
	</tr>
	</table>
          
    <!-- Button to send data -->
    <button id="sendButton" onclick="myAjaxGoGo()">Send JSON</button>
  
    <!-- For printing result from server -->
    <p id="resultBox" style="color:green"></p>   
    
    <div>
      <canvas id="myChart"></canvas>
   </div>
</p>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const chartConfig = {
	type: 'line',
	options: {
		scales: {
			y: {
				reverse: true
			}
		}
     }
};
const myChart = new Chart(document.getElementById('myChart'), chartConfig);
myChart.reset();
	
function myAjaxGoGo(){ 

	let fromVal = document.getElementById("fromVal").value;
	// Validate fromVal 
	var patternForInputVal=/^-?(\d+(\.\d+)?|\.\d+)$/;
	if (!patternForInputVal.test(fromVal)) {
		alert("Invalid number in textbox: " + fromVal);
		return;
	}
	
	let toVal = document.getElementById("toVal").value;
	// Validate toVal 
	if (!patternForInputVal.test(toVal)) {
		alert("Invalid number in textbox: " + toVal);
		return;
	}

	let result = document.getElementById("resultBox");
	
	// Creating a XHR object 
	let xhr = new XMLHttpRequest(); 
	let url = "https://godbolt.org/api/compiler/g63/compile"; 

	// open a connection 
	xhr.open("POST", url, true); 

	// Set the request header i.e. which type of content you are sending 
	xhr.setRequestHeader("Content-Type", "application/json"); 

	// Create a state change callback 
	xhr.onreadystatechange = function () { 
	
		document.getElementById("sendButton").disabled=false;
	
		if (xhr.readyState === 4 && xhr.status === 200) { 

			// Analyze server result:
			var location = this.responseText.lastIndexOf("####RESULT:");
			if (-1 == location) {
				result.innerHTML = this.responseText; 
			}
			else {
				// Got something that looks like our expected result:
				const resultLines = this.responseText.substring(location + "####RESULT:".length).split("\n");
				if (resultLines.length >= 1) {
					result.innerHTML = resultLines[0];
					
					// Results for chart in lines [1] and [2]:
					if (resultLines.length >= 3) {
						const labels = resultLines[1].split(",");
						const precisions = resultLines[2].split(",").map(x => parseFloat(x));

						const chartData = {
							labels: labels,
							datasets: [{
							  label: 'Precision',
							  backgroundColor: 'rgb(0, 203, 230)',
							  borderColor: 'rgb(0, 203, 230)',
							  data: precisions,
							}]
						  };

						chartConfig.data = chartData;
						myChart.update('active');
					}
				}
			}
		} 
	}; 
			
	var cppCode = 
	"#include <iostream>                                                                        \n" + 
	"#include <algorithm>                                                                       \n" + 
	"#include <array>                                                                           \n" + 
	"float precision_for(float reference) {                                                     \n" + 
	"	unsigned long long i = *reinterpret_cast<unsigned long long*>(&reference);              \n" + 
	"    unsigned long long j = i+1;                                                            \n" + 
	"    float more = *reinterpret_cast<float*>(&j);                                            \n" + 
	"	unsigned long long k = i-1;                                                             \n" + 
	"	float less = *reinterpret_cast<float*>(&k);                                             \n" + 
	"    float precision = std::max(more - reference, reference - less);                        \n" + 
	"	return precision;                                                                       \n" + 
	"}                                                                                          \n" + 
	"struct result {                                                                            \n" + 
	"    float mValue;                                                                          \n" + 
	"    float mPrecision;                                                                      \n" + 
	"};                                                                                         \n" + 
	"int main () {                                                                              \n" + 
	"    float from = static_cast<float>({FROM});                                               \n" + 
	"    float to = static_cast<float>({TO});                                                   \n" + 
	"    constexpr int n = 30;                                                                  \n" + 
	"    float delta = (to - from) / static_cast<float>(n);                                     \n" + 
	"    std::array<result, n + 1> results;                                                     \n" + 
	"    for (int i = 0; i < n; ++i) {                                                          \n" + 
	"        results[i].mValue = from + static_cast<float>(i) * delta;                          \n" + 
	"        results[i].mPrecision = precision_for(results[i].mValue);                          \n" + 
	"    }                                                                                      \n" + 
	"    results[n] = { to, precision_for(to) };                                                \n" + 
	"    float worstPrecision = std::max(results.front().mPrecision, results.back().mPrecision);\n" + 
	"                                                                                           \n" + 
	"    std::cout << \"####RESULT:\" << std::defaultfloat << worstPrecision << std::endl;      \n" + 
	"    std::cout << std::fixed;                                                               \n" + 
	"    for (int i = 0; i < n; ++i) {                                                          \n" + 
	"        std::cout << results[i].mValue << \",\";                                           \n" + 
	"    }                                                                                      \n" + 
	"    std::cout << results[n].mValue << std::endl;                                           \n" + 
	"    std::cout << std::defaultfloat;                                                        \n" + 
	"    for (int i = 0; i < n; ++i) {                                                          \n" + 
	"        std::cout << results[i].mPrecision << \",\";                                       \n" + 
	"    }                                                                                      \n" + 
	"    std::cout << results[n].mPrecision << std::endl;                                       \n" + 
	"    return 1;                                                                              \n" + 
	"}\n";

	// Converting JSON data to string 
	var data = JSON.stringify({
		"source": cppCode.replace("{FROM}", fromVal).replace("{TO}", toVal),
		"compiler": "g82",
		"options": {
			"userArguments": "-O3",
			"executeParameters": {
				"args": ["arg1", "arg2"],
				"stdin": "hello, world!"
			},
			"compilerOptions": {
				"executorRequest": true
			},
			"filters": {
				"execute": true
			},
			"tools": [],
			"libraries": [
				{"id": "openssl", "version": "111c"}
			]
		},
		"lang": "c++",
		"allowStoreCodeDebug": true
	}); 

	// Sending data with the request 
	xhr.send(data); 

	document.getElementById("sendButton").disabled=true;
} 

</script>
