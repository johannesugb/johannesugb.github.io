---
title: "Why projection matrices typically used with OpenGL fail with Vulkan"
# last_modified_at: 2021-05-01T18:00:00+02:00
categories:
  - GPU-Programming
tags:
  - Vulkan
# header:
#   image: /assets/images/1500x500.jpg
---

When programmers with an OpenGL background learn Vulkan, they often expect--or hope--that the projection matrices they have used with OpenGL continue to work with Vulkan. Everyone with such expectations is in for a bad surprise. While many sources on the internet offer strategies to fix it such as

- Inverting the projection matrix' y-axis: `projMat[1][1] *= -1`,
- Inverting the y coordinates in the vertex shader: `gl_Position.y = -gl_Position.y;`,
- Flipping the viewport by specifying a negative height,
- Inverting a mysterious value in the projection matrix: `projMat[3][2] *= -1;`,

and some require changing the front faces from [`VK_FRONT_FACE_COUNTER_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html) to [`VK_FRONT_FACE_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html).

Applying such changes without really knowing what's going on under the hood can leave a bad feeling in the mind of a thoughtful programmer. This blog post tries to explain why OpenGL's projection matrices do not work in a Vulkan application without modification and what the fundamental differences between the two APIs are in this specific case.

## Projection Matrices in OpenGL

Before we can analyze the differences between Vulkan and OpenGL, we might be interested in getting a feeling for typical OpenGL projection matrices which look like follows:

$$ \begin{pmatrix}
\frac{2 n}{r - l} & 0 & \frac{r + l}{r - l} & 0 \\
0 & \frac{2 n}{t - b} & \frac{t + b}{t - b} & 0 \\
0 & 0 & -\frac{f + n}{f - n} & \frac{2 f n}{f - n} \\
0 & 0 & -1 & 0 
\end{pmatrix} $$      

_Equation 1:_ Typical OpenGL projection matrix as generated by good old [`glFrustum`](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml) (or with better formatting here: [Scratchpixel 2.0 - The Perspective and Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix). 

Now, this might look a bit complicated at first glance, but the fundamental ideas are not so involved once we simplify it a bit. The variables refer to: near plane distance $n$, far plane distance $f$, left and right frustum boundaries $l$ and $r$, top and bottom frustum boundaries $t$ and $b$. These parameters are for transforming a scene into a unit cube. Let us simplify computations by assuming that our entire scene is contained within unit cube bounds already, then the projection matrix looks a lot simpler turns from its form in _Equation 1_ into the form in _Equation 2_:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -4 \\
0 & 0 & -1 & 0 
\end{pmatrix} $$          

_Equation 2:_ Projection matrix with parameters $l = -1$, $r = 1$, $b = -1$, $t = 1$, $n = 1$, and $f = 2$.

What I would like to point out now is how this projection matrix transforms coordinates. And then we are about to whitness some---in my opinion---rather ugly conventions which have the potential to lead to a lot of confusion. Transforming a generic homogeneous 3D vector with _Equation 2_ leads to the result shown in _Equation 3_:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix}            \cdot 
\begin{pmatrix}
x \\
y \\
z \\
1 \end{pmatrix}            = 
\begin{pmatrix}
x \\
y \\
-3z-4 \\
-z  
\end{pmatrix} $$         

_Equation 3:_ Transforming a homogeneous 3D vector with the projection matrix from _Equation 2_.

While it leaves $x$ and $y$ coordinates untouched, $z$ cooordinates get **flipped**. Furthermore, we get a **negative homogeneous coordinate**. 
Flipping of one coordinate axis _only_, while not flipping the other two axes, corresponds to **changing the handedness** of the coordinate system as illustrated in _Figure 1_.

{: .center}
[![Flipping the z-axis only](/assets/images/inv-z-fade.gif)](/assets/images/inv-z-fade.gif)

_Figure 1:_ Illustration of the transformation from _Equation 3_. Matrix multiplication, of course, would not lead to a gradual interpolation like shown in the animation; the animation's intent is to emphasize the painful transformation from the original right-handed coordinate system into a left-handed coordinate system.

The coordinate system that results from it is left-handed. OpenGL's convention says that framebuffer space shall be left-handed, too, with its x-axis pointing to the right, its y-axis is pointing up, and its z-axis (which represents depth values) pointing "into" the screen (i.e. _not_ out of it). A nice illustration of the different framebuffer coordinates spaces in screen space can be found under [Sascha Willems - Flipping the Vulkan viewport](https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/). 

And with this information, let us move on to the differences between OpenGL and Vulkan.

## Different Space Conventions for OpenGL and Vulkan

We have already learnt about the different space conventions of framebuffer space (if you have followed the link given right above). But where it gets really interesting are the spaces before framebuffer space, which are clip space and normalized device coordinates (NDC space). _Figure 2_ shows some typical spaces of a 3D application (referring to world space and view space) along with the spaces that graphics APIs define: clip space, NDC space, and framebuffer space.

{: .center}
[![Graphics pipeline, different spaces and operations](/assets/images/different_spaces_and_ops.png)](/assets/images/different_spaces_and_ops.png)

_Figure 2:_ Typical spaces in a 3D application include world and view space, which are generally user-defined. Graphics APIs dictate some conventions about other spaces, though, namely clip space, NDC space, and framebuffer space. Between clip space and NDC space several fixed-function operations are performed (from left to right: backface culling, primitive clipping, homogeneous division) which are indicated with circular symbols. Different spaces are indicated with rectangles.

What we have talked about so far is the projection matrix $P$ which transforms into clip space. A key point which needs to be understood is that **the graphics API** defines how clip space shall look like. And here we have differences between OpenGL and Vulkan: While OpenGL expects the clip space to be _left-handed_, Vulkan expects it to be _right-handed_. There are several crucial fixed-function operations happening between clip space and NDC space (shown in _Figure 2_) which are performed in the following order:

1. Backface culling
2. Primitive clipping
3. Homogeneous division

Only _after_ all these steps, clip space coordinates have been fully transformed into NDC space. What I would like to emphasize here again is that these steps are performed in spaces with different handedness when comparing OpenGL with Vulkan. _Figures 3 and 4_ show the differences between OpenGL and Vulkan w.r.t. their clip and NDC spaces.

{: .center}
[![Clip Space and Normalized Device Coordinates details in OpenGL](/assets/images/clip_cube_ndc_cube_opengl.png)](/assets/images/clip_cube_ndc_cube_opengl.png)

_Figure 3:_ OpenGL expects coordinates in clip space to be given in a left-handed coordinate system, supporting homogeneous coordinates. Handedness stays the same through the operations between clip space and NDC space. The left-handed coordinate system naturally translates to OpenGL's framebuffer space, which defines the coordinate origin in the bottom-left corner, with its x-axis pointing to the right and its y-axis pointing up.

{: .center}
[![Clip Space and Normalized Device Coordinates details in Vulkan](/assets/images/clip_cube_ndc_cube_vulkan.png)](/assets/images/clip_cube_ndc_cube_vulkan.png)

_Figure 4:_ Vulkan expects coordinates in clip space to be given in a right-handed coordinate system, supporting homogeneous coordinates. Handedness stays the same through the operations between clip space and NDC space. The right-handed coordinate system naturally translates to Vulkan's framebuffer space, which defines the coordinate origin in the top-left corner, with its x-axis pointing to the right and its y-axis pointing down.

At this point, there is one thing which looks quite fishy in particular---at least that's how it appeared to me before I started investigating: I was wondering why on earth do both APIs, OpenGL and Vulkan alike, base their backface culling decision on the _same_ winding order w.r.t. a _right-handed_ coordinate system when one API acts on left-handed clip space and the other acts on right-handed clip space? Backface culling clearly comes after the transformation into clip space, i.e. the two APIs are using spaces of different handedness. The [cross product](https://en.wikipedia.org/wiki/Cross_product), which can be used to compute a triangle's face normal, is defined so that if vertices are given in counter-clockwise direction, its resulting vector (which serves as the face normal) is created according to the _right-hand rule_. Wouldn't OpenGL need to have winding orders exactly the other way round, given that it operates on a _left-handed_ clip space?!

The specifications give the answer: The [OpenGL specification](https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf) suggests a specific formula for computing whether or not a polygon is backfacing or frontfacing (Section 14.6.1 Basic Polygon Rasterization, Equation 14.8). The [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html) also suggests a specific formula for this purpose (Section 27.12.1. Basic Polygon Rasterization) which almost looks the same as OpenGL's formula, it just has an additional minus sign which makes all the difference. I.e., the formulae which determine if a polygon is frontfacing or backfacing that are used in both APIs _internally_ indeed compute exactly the opposite results w.r.t. each other. However, OpenGL does this in a _left-handed_ clip space while Vulkan operates in a _right-handed_ clip space. If this thought is followed back into an imagined right-handed world space, the front faces of polygons are _the same_ again w.r.t. their winding order. 

I find this pretty confusing. I'd assume that misconceptions like OpenGL would require right-handed world space originate from these properties, when actually the only spaces that OpenGL really defines a handedness for, are all _left-handed_, but---as outlined above---right-hand rules are applied when determining whether a polygon is frontfacing or backfacing. 

I find these properties much less confusing in Vulkan. In Khronos' newer API, everything feels more consistent for its fixed-function steps, applying right-handed rules and performing everything in right-handed spaces. The only "downside" (if it could even be labeled as such) might be that a framebuffer space with its y-axis pointing down could be more confusing to some. However, taking Vulkan's NDC space into account (as shown in _Figure 4_), I think it just is the natural choice and makes sense, totally.

## What Do Those Initially Mentioned Strategies Actually Do

Most of the strategies mentioned initially flip another axis of a given OpenGL-style projection matrix. In particular, this applies to the first three items from above:

- Inverting the projection matrix' y-axis: `projMat[1][1] *= -1`,
- Inverting the y coordinates in the vertex shader: `gl_Position.y = -gl_Position.y;`,
- Flipping the viewport by specifying a negative height.

The process can be visualized like follows:

{: .center}
[![Flipping the z-axis and flipping the y-axis](/assets/images/inv-z-then-y-fade.gif)](/assets/images/inv-z-then-y-fade.gif)

_Figure 5:_ If first, one axis (the z-axis in this case) is flipped like in _Figure 1_---corresponding to what a typical OpenGL projection matrix does---, and then another axis (the y-axis in this case) is flipped additionally, the resulting coordinate system is right-handed again. 

From _Figure 5_ it can be seen that the result is a right-handed coordinate system, i.e. exactly what Vulkan expects. Flipping two axes corresponds to a rotation like shown in _Figure 6_, which is an [orthogonal transformation](https://en.wikipedia.org/wiki/Orthogonal_transformation) and as such, preserves handedness.

{: .center}
[![Rotating a right-handed coordinate system](/assets/images/inv-not-but-rot-fade.gif)](/assets/images/inv-not-but-rot-fade.gif)

_Figure 6:_ The transformation illustrated in _Figure 5_ corresponds to a stiff rotation which preserves handedness.

Now we do have a right-handed coordinate system, but it might be that we have messed up some axes along the way. E.g., it might be that if we carelessly applied one of these strategies, we could end up with a situation such as our camera looking in an unexpected direction after multiplying view and (changed) projection matrices togehter. I won't go into details of specific cases but instead, I'll create another blog post describing how a proper projection matrix for Vulkan might be set-up. 

We complete our adventurous journey with a brief discussion of the effects of the fourth initially mentioned strategy: 

- Inverting a mysterious value in the projection matrix: `projMat[3][2] *= -1;`.

The modification of the projection matrix in this case reverts the flipping of the z-axis but leaves the homogeneous coordinate with a negative sign, which means that homogeneous division flips every axis---probably with the intention of getting the depth values right by letting the resulting z-axis point "into" the screen. As hinted above, everything with these spaces is relative to the other spaces, but it can get hugely confusing and I would assume that a solution that has been hacked together is not what the thoughtful programmer is after.

As soon as I'll have the blog post about my take on establishing a proper Vulkan projection matrix is done, I'll add a link to it here. Thanks for reading!
