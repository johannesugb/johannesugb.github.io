---
title: "Why projection matrices typically used with OpenGL fail with Vulkan"
# last_modified_at: 2021-05-01T18:00:00+02:00
categories:
  - GPU-Programming
tags:
  - Vulkan
# header:
#   image: /assets/images/1500x500.jpg
---

When programmers with an OpenGL background learn Vulkan, they often expect--or hope--that the projection matrices they have used with OpenGL continue to work with Vulkan. Everyone with such expectations is in for a bad surprise. While many sources on the internet offer quick fixes such as

- Inverting the projection matrix' y-axis: `projMat[1][1] *= -1`
- Inverting the y coordinates in the vertex shader: `gl_Position.y = -gl_Position.y;`
- Inverting the projection matrix' z-axis: `projMat[2][3] *= -1` (TODO: check!)
- Changing the front faces from [`VK_FRONT_FACE_COUNTER_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html) to [`VK_FRONT_FACE_CLOCKWISE`](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html)

Applying such fixes without really knowing what's going on under the hood can leave a bad feeling in the mind of a thoughtful programmer. This blog post tries to explain why OpenGL's projection matrices do not work in a Vulkan application without modification and what the fundamental differences between the two APIs are in this specific case.

## Projection Matrices in OpenGL

Before we can analyze the differences between Vulkan and OpenGL, we should try to understand what happens in OpenGL and why projection matrices of the following form are used:

$$ \begin{pmatrix}
\frac{2 n}{r - l} & 0 & \frac{r + l}{r - l} & 0 \\
0 & \frac{2 n}{t - b} & \frac{t + b}{t - b} & 0 \\
0 & 0 & -\frac{f + n}{f - n} & -1 \\
0 & 0 & \frac{2 f n}{f - n} & 0 
\end{pmatrix} $$      

_Equation 1:_ Typical OpenGL projection matrix as generated by good old [`glFrustum`](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml) (or with better formatting here: [Scratchpixel 2.0 - The Perspective and Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix). 

Now, this might look a bit complicated at first glance, but the fundamental ideas are not so involved once we simplify it a bit. The variables refer to: near plane distance $n$, far plane distance $f$, left and right frustum boundaries $l$ and $r$, top and bottom frustum boundaries $t$ and $b$. These parameters are for transforming a scene into a unit cube. Let us simplify computations by assuming that our entire scene is contained within unit cube bounds already, then the projection matrix looks a lot simpler turns from its form in _Equation 1_ into the form in _Equation 2_:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix} $$          

_Equation 2:_ Projection matrix with parameters $l = -1$, $r = 1$, $b = -1$, $t = 1$, $n = 1$, and $f = 2$.

What I would like to point out now is how this projection matrix transforms coordinates. We are about to whitness some---in my opinion---rather ugly conventions which have the potential to lead to a lot of confusion. 

_Speaking of confusion, a sidenote:_ Don't let yourself be confused by the positions of the $-1$ and $-4$ entries in _Equation 2_; you'll find their positions swapped in many references. This comes from taking taking storage peculiarities into account---namely row-mayor vs. column-major. In this blog post, however, I display matrices in generic mathematical notation s.t. it matches the notation from e.g. [WolframAlpha](https://www.wolframalpha.com/input/?i=%7B%7B1%2C+0%2C+0%2C+0%7D%2C+%7B0%2C+1%2C+0%2C+0%7D%2C+%7B0%2C+0%2C+-3%2C+-1%7D%2C+%7B0%2C+0%2C+-4%2C+0%7D%7D+.+%7B%7Bx%7D%2C+%7By%7D%2C+%7Bz%7D%2C+%7B1%7D%7D) and other mathematical sources.

Okay, back to the projection matrix. Let us investigate what it does to coordinate values by using it to transform a homogeneous 3D vector:

$$ \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -3 & -1 \\
0 & 0 & -4 & 0 
\end{pmatrix}            \cdot 
\begin{pmatrix}
x \\
y \\
z \\
1 \end{pmatrix}            = 
\begin{pmatrix}
x \\
y \\
-3z-1 \\
-4z  
\end{pmatrix} $$         

_Equation 3:_ Transforming a homogeneous 3D vector with the projection matrix from _Equation 2_.

While it leaves $x$ and $y$ coordinates untouched, $z$ cooordinates get **flipped**. Furthermore, we get a **negative homogeneous coordinate**. 
Flipping of one coordinate axis _only_, while not flipping the other two axes, corresponds to **changing the handedness** of the coordinate system as illustrated in _Figure 1_.

{: .center}
[![Flipping the z-axis only](/assets/images/inv-z-fade.gif)](/assets/images/inv-z-fade.gif)

_Figure 1:_ Illustration of the transformation from _Equation 3_. Matrix multiplication, of course, would not lead to a gradual interpolation like shown in the animation; the animation's intent is to emphasize the painful transformation from the original right-handed coordinate system into a left-handed coordinate system.

The coordinate system that results from it is left-handed because OpenGL's convention of framebuffer coordinates are so that in screen space the x-axis is pointing to the right, y-axis is pointing up, and the z-axis (which represents depth values) points "into" the screen (i.e. _not_ out of it). A nice illustration of the different framebuffer coordinates spaces in screen space can be found under [Sascha Willems - Flipping the Vulkan viewport](https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/). 

And with this information, let us move on to the differences between OpenGL and Vulkan.

## Different Space Conventions for OpenGL and Vulkan

We have already learnt about the different space conventions of framebuffer coordinates and screen space. But where it gets really interesting are the spaces before screen space, which are clip space and normalized device coordinates (NDC space). _Figure 2_ shows some typical spaces of a 3D application (referring to world space and view space) along with the spaces that graphics APIs define: clip space, NDC space, and framebuffer space.

{: .center}
[![Graphics pipeline, different spaces and operations](/assets/images/different_spaces_and_ops.png)](/assets/images/different_spaces_and_ops.png)

_Figure 2:_ Typical spaces in a 3D application include world and view space, which are generally-user defined. Graphics pipelines dictate some conventions about other spaces, though, namely clip space, NDC space, and framebuffer space. Between clip space and NDC space several fixed-function operations are performed (from left to right: backface culling, primitive clipping, homogeneous division) which are indicated with circular symbols. Different spaces are indicated with rectangles.

What we have talked about so far is the projection matrix $P$ which transforms into clip space. A key point which needs to be understood is that **the graphics API** defines how clip space shall look like. And here we have differences between OpenGL and Vulkan: While OpenGL expects the clip space to be _left-handed_, Vulkan expects it to be _right-handed_. There are several crucial fixed-function operations happening between clip space and NDC space (shown in _Figure 2_) which are performed in the following order:

1. Backface culling
2. Primitive clipping
3. Homogeneous division

Only _after_ all these steps, clip space coordinates have been fully transformed into NDC space. What I would like to emphasize here again is that these steps are performed in spaces with different handedness when comparing OpenGL with Vulkan. _Figures 3 and 4_ illustrate the two spaces in detail for OpenGL and Vulkan, respectively.

{: .center}
[![Clip Space and Normalized Device Coordinates details in OpenGL](/assets/images/clip_cube_ndc_cube_opengl.png)](/assets/images/clip_cube_ndc_cube_opengl.png)

_Figure 3:_ OpenGL expects coordinates in clip space to be given in a left-handed coordinate system, supporting homogeneous coordinates. Handedness stays the same through the operations between clip space and NDC space. The left-handed coordinate system naturally translates to OpenGL's framebuffer space, which defines the coordinate origin in the bottom-left corner, with its x-axis pointing to the right and its y-axis pointing up.

{: .center}
[![Clip Space and Normalized Device Coordinates details in Vulkan](/assets/images/clip_cube_ndc_cube_vulkan.png)](/assets/images/clip_cube_ndc_cube_vulkan.png)

_Figure 4:_ Vulkan expects coordinates in clip space to be given in a right-handed coordinate system, supporting homogeneous coordinates. Handedness stays the same through the operations between clip space and NDC space. The right-handed coordinates system naturally translates to Vulkan's framebuffer space, which defines the coordinate origin in the top-left corner, with its x-axis pointing to the right and its y-axis pointing down.

At this point, there is one thing which looks quite fishy---at least that how it appeared to me before I started investigating: I was wondering why on earth do both APIs, OpenGL and Vulkan alike, base their backface culling decision on the _same_ winding order w.r.t. a _right-handed_ coordinate system when one API acts on left-handed clip space and the other acts on right-handed clip space? Backface culling clearly comes after the transformation into clip space, i.e. the two APIs are using spaces of different handedness. The [cross product](https://en.wikipedia.org/wiki/Cross_product), which can be used to compute the the face normal, is defined so that if vertices are given in counter-clockwise direction, its resulting vector (which serves as the face normal) is created according to the _right-hand rule_. Wouldn't OpenGL need to have winding orders exactly the other way round, given that it operates on a _left-handed_ clip space?!

The specifications give the answer: The [OpenGL specification](https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf) suggests a specific formula for computing whether or not a polygon is backfacing or frontfacing (Section 14.6.1 Basic Polygon Rasterization, Equation 14.8). The [Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html) also suggests a specific formula for this purpose (Section 27.12.1. Basic Polygon Rasterization) which almost looks the same as OpenGL's formula, it just has an additional minus sign which makes all the difference. I.e., the formulae which determine if a polygon is frontfacing or backfacing that are used in both APIs _internally_ indeed compute exactly the opposite results w.r.t. each other. However, OpenGL does this in a _left-handed_ clip space while Vulkan assumes a _right-handed_ clip space. If this thought is followed back into an imagined right-handed world space, the front faces of polygons are _the same_ again w.r.t. their winding order. 

I find this pretty confusing. I'd assume that misconceptions like OpenGL would require right-handed world space originate from these properties, when actually the only spaces that OpenGL really defines a handedness for, are all _left-handed_, but---as outlined above---right-hand rules are applied when determining whether a polygon is frontfacing or backfacing. 

I find these properties much less confusing in Vulkan. In Khronos' newer API, everything feels more consistent, applying right-handed rules and performing everything in right-handed spaces. The only "downside" (if it could even be labeled as such) might be that a framebuffer space with its y-axis pointing down could be more confusing to some. However, taking Vulkan's NDC space into account (as shown in _Figure 4_), I think it just is the natural choice and makes sense, totally.
